// Targeted by JavaCPP version 1.3: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class wlc extends org.bytedeco.javacpp.helper.wlc {
    static { Loader.load(); }

// Parsed from <wlc/wlc.h>

// #ifndef _WLC_H_
// #define _WLC_H_

// #ifdef __cplusplus
// #endif

// #include <wlc/defines.h>
// #include <wlc/geometry.h>
// #include <xkbcommon/xkbcommon-keysyms.h>
// #include <sys/types.h>

@Opaque public static class wlc_event_source extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public wlc_event_source() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wlc_event_source(Pointer p) { super(p); }
}

@Opaque public static class xkb_state extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public xkb_state() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public xkb_state(Pointer p) { super(p); }
}
@Opaque public static class xkb_keymap extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public xkb_keymap() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public xkb_keymap(Pointer p) { super(p); }
}
@Opaque public static class libinput_device extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public libinput_device() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public libinput_device(Pointer p) { super(p); }
}

/** wlc_log(), wlc_vlog(); */
/** enum wlc_log_type */
public static final int
   WLC_LOG_INFO = 0,
   WLC_LOG_WARN = 1,
   WLC_LOG_ERROR = 2,
   WLC_LOG_WAYLAND = 3;

/** wlc_get_backend_type(); */
/** enum wlc_backend_type */
public static final int
   WLC_BACKEND_NONE = 0,
   WLC_BACKEND_DRM = 1,
   WLC_BACKEND_X11 = 2;

/** mask in wlc_event_loop_add_fd(); */
/** enum wlc_event_bit */
public static final int
   WLC_EVENT_READABLE =  0x01,
   WLC_EVENT_WRITABLE =  0x02,
   WLC_EVENT_HANGUP =  0x04,
   WLC_EVENT_ERROR =  0x08;

/** wlc_view_get_state(); */
/** enum wlc_view_state_bit */
public static final int
   WLC_BIT_MAXIMIZED =  1<<0,
   WLC_BIT_FULLSCREEN =  1<<1,
   WLC_BIT_RESIZING =  1<<2,
   WLC_BIT_MOVING =  1<<3,
   WLC_BIT_ACTIVATED =  1<<4;

/** wlc_view_get_type(); */
/** enum wlc_view_type_bit */
public static final int
   WLC_BIT_OVERRIDE_REDIRECT =  1<<0, // Override redirect (x11)
   WLC_BIT_UNMANAGED =  1<<1, // Tooltips, DnD's, menus (x11)
   WLC_BIT_SPLASH =  1<<2, // Splash screens (x11)
   WLC_BIT_MODAL =  1<<3, // Modal windows (x11)
   WLC_BIT_POPUP =  1<<4; // xdg-shell, wl-shell popups

/** wlc_set_view_properties_updated_cb(); */
/** enum wlc_view_property_update_bit */
public static final int
   WLC_BIT_PROPERTY_TITLE =  1<<0,
   WLC_BIT_PROPERTY_CLASS =  1<<1,
   WLC_BIT_PROPERTY_APP_ID =  1<<2,
   WLC_BIT_PROPERTY_PID =  1<<3;

/** wlc_view_set_geometry(); Edges in interface interface.view.request.resize function. */
/** enum wlc_resize_edge */
public static final int
   WLC_RESIZE_EDGE_NONE = 0,
   WLC_RESIZE_EDGE_TOP = 1,
   WLC_RESIZE_EDGE_BOTTOM = 2,
   WLC_RESIZE_EDGE_LEFT = 4,
   WLC_RESIZE_EDGE_TOP_LEFT = 5,
   WLC_RESIZE_EDGE_BOTTOM_LEFT = 6,
   WLC_RESIZE_EDGE_RIGHT = 8,
   WLC_RESIZE_EDGE_TOP_RIGHT = 9,
   WLC_RESIZE_EDGE_BOTTOM_RIGHT = 10;

/** Mods in interface.keyboard.key function. */
/** enum wlc_modifier_bit */
public static final int
   WLC_BIT_MOD_SHIFT =  1<<0,
   WLC_BIT_MOD_CAPS =  1<<1,
   WLC_BIT_MOD_CTRL =  1<<2,
   WLC_BIT_MOD_ALT =  1<<3,
   WLC_BIT_MOD_MOD2 =  1<<4,
   WLC_BIT_MOD_MOD3 =  1<<5,
   WLC_BIT_MOD_LOGO =  1<<6,
   WLC_BIT_MOD_MOD5 =  1<<7;

/** Leds in interface.keyboard.key function. */
/** enum wlc_led_bit */
public static final int
   WLC_BIT_LED_NUM =  1<<0,
   WLC_BIT_LED_CAPS =  1<<1,
   WLC_BIT_LED_SCROLL =  1<<2;

/** State in interface.keyboard.key function. */
/** enum wlc_key_state */
public static final int
   WLC_KEY_STATE_RELEASED = 0,
   WLC_KEY_STATE_PRESSED = 1;

/** State in interface.pointer.button function. */
/** enum wlc_button_state */
public static final int
   WLC_BUTTON_STATE_RELEASED = 0,
   WLC_BUTTON_STATE_PRESSED = 1;

/** Axis in interface.pointer.scroll function. */
/** enum wlc_scroll_axis_bit */
public static final int
   WLC_SCROLL_AXIS_VERTICAL =  1<<0,
   WLC_SCROLL_AXIS_HORIZONTAL =  1<<1;

/** Type in interface.touch.touch function */
/** enum wlc_touch_type */
public static final int
   WLC_TOUCH_DOWN = 0,
   WLC_TOUCH_UP = 1,
   WLC_TOUCH_MOTION = 2,
   WLC_TOUCH_FRAME = 3,
   WLC_TOUCH_CANCEL = 4;

/** State of keyboard modifiers in various functions. */
public static class wlc_modifiers extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wlc_modifiers() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wlc_modifiers(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wlc_modifiers(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wlc_modifiers position(long position) {
        return (wlc_modifiers)super.position(position);
    }

   public native @Cast("uint32_t") int leds(); public native wlc_modifiers leds(int leds);
   public native @Cast("uint32_t") int mods(); public native wlc_modifiers mods(int mods);
}

/** -- Callbacks API */

/** Output was created. Return false if you want to destroy the output. (e.g. failed to allocate data related to view) */
public static class Cb_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer(Pointer p) { super(p); }
    protected Cb_Pointer() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer output);
}
public static native void wlc_set_output_created_cb(Cb_Pointer cb);

/** Output was destroyed. */
public static native void wlc_set_output_destroyed_cb(Cb_Pointer cb);

/** Output got or lost focus. */
public static class Cb_Pointer_boolean extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_boolean(Pointer p) { super(p); }
    protected Cb_Pointer_boolean() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("bool") boolean focus);
}
public static native void wlc_set_output_focus_cb(Cb_Pointer_boolean cb);

/** Output resolution changed. */
public static class Cb_Pointer_wlc_size_wlc_size extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_wlc_size_wlc_size(Pointer p) { super(p); }
    protected Cb_Pointer_wlc_size_wlc_size() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer output, @Const wlc_size from, @Const wlc_size to);
}
public static native void wlc_set_output_resolution_cb(Cb_Pointer_wlc_size_wlc_size cb);

/** Output pre render hook. */
public static native void wlc_set_output_render_pre_cb(Cb_Pointer cb);

/** Output post render hook. */
public static native void wlc_set_output_render_post_cb(Cb_Pointer cb);

/** Output context is created. This generally happens on startup and when current tty changes */
public static native void wlc_set_output_context_created_cb(Cb_Pointer cb);

/** Output context was destroyed. */
public static native void wlc_set_output_context_destroyed_cb(Cb_Pointer cb);

/** View was created. Return false if you want to destroy the view. (e.g. failed to allocate data related to view) */
public static native void wlc_set_view_created_cb(Cb_Pointer cb);

/** View was destroyed. */
public static native void wlc_set_view_destroyed_cb(Cb_Pointer cb);

/** View got or lost focus. */
public static native void wlc_set_view_focus_cb(Cb_Pointer_boolean cb);

/** View was moved to output. */
public static class Cb_Pointer_Pointer_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_Pointer_Pointer(Pointer p) { super(p); }
    protected Cb_Pointer_Pointer_Pointer() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @ByVal @Cast("wlc_handle*") Pointer from_output, @ByVal @Cast("wlc_handle*") Pointer to_output);
}
public static native void wlc_set_view_move_to_output_cb(Cb_Pointer_Pointer_Pointer cb);

/** Request to set given geometry for view. Apply using wlc_view_set_geometry to agree. */
public static class Cb_Pointer_wlc_geometry extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_wlc_geometry(Pointer p) { super(p); }
    protected Cb_Pointer_wlc_geometry() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @Const wlc_geometry arg1);
}
public static native void wlc_set_view_request_geometry_cb(Cb_Pointer_wlc_geometry cb);

/** Request to disable or enable the given state for view. Apply using wlc_view_set_state to agree. */
public static class Cb_Pointer_int_boolean extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_boolean(Pointer p) { super(p); }
    protected Cb_Pointer_int_boolean() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("wlc_view_state_bit") int arg1, @Cast("bool") boolean toggle);
}
public static native void wlc_set_view_request_state_cb(Cb_Pointer_int_boolean cb);

/** Request to move itself. Start a interactive move to agree. */
public static class Cb_Pointer_wlc_point extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_wlc_point(Pointer p) { super(p); }
    protected Cb_Pointer_wlc_point() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @Const wlc_point arg1);
}
public static native void wlc_set_view_request_move_cb(Cb_Pointer_wlc_point cb);

/** Request to resize itself with the given edges. Start a interactive resize to agree. */
public static class Cb_Pointer_int_wlc_point extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_point(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_point() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int edges, @Const wlc_point arg2);
}
public static native void wlc_set_view_request_resize_cb(Cb_Pointer_int_wlc_point cb);

/** View pre render hook. */
public static native void wlc_set_view_render_pre_cb(Cb_Pointer cb);

/** View post render hook. */
public static native void wlc_set_view_render_post_cb(Cb_Pointer cb);

/** View properties (title, class, app_id) was updated */
public static class Cb_Pointer_int extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int(Pointer p) { super(p); }
    protected Cb_Pointer_int() { allocate(); }
    private native void allocate();
    public native void call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int mask);
}
public static native void wlc_set_view_properties_updated_cb(Cb_Pointer_int cb);

/** Key event was triggered, view handle will be zero if there was no focus. Return true to prevent sending the event to clients. */
public static class Cb_Pointer_int_wlc_modifiers_int_int extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_modifiers_int_int(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_modifiers_int_int() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int time, @Const wlc_modifiers arg2, @Cast("uint32_t") int key, @Cast("wlc_key_state") int arg4);
}
public static native void wlc_set_keyboard_key_cb(Cb_Pointer_int_wlc_modifiers_int_int cb);

/** Button event was triggered, view handle will be zero if there was no focus. Return true to prevent sending the event to clients. */
public static class Cb_Pointer_int_wlc_modifiers_int_int_wlc_point extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_modifiers_int_int_wlc_point(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_modifiers_int_int_wlc_point() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int time, @Const wlc_modifiers arg2, @Cast("uint32_t") int button, @Cast("wlc_button_state") int arg4, @Const wlc_point arg5);
}
public static native void wlc_set_pointer_button_cb(Cb_Pointer_int_wlc_modifiers_int_int_wlc_point cb);

/** Scroll event was triggered, view handle will be zero if there was no focus. Return true to prevent sending the event to clients. */
public static class Cb_Pointer_int_wlc_modifiers_byte_DoublePointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_modifiers_byte_DoublePointer(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_modifiers_byte_DoublePointer() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int time, @Const wlc_modifiers arg2, @Cast("uint8_t") byte axis_bits, DoublePointer amount);
}
public static native void wlc_set_pointer_scroll_cb(Cb_Pointer_int_wlc_modifiers_byte_DoublePointer cb);
public static class Cb_Pointer_int_wlc_modifiers_byte_DoubleBuffer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_modifiers_byte_DoubleBuffer(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_modifiers_byte_DoubleBuffer() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int time, @Const wlc_modifiers arg2, @Cast("uint8_t") byte axis_bits, DoubleBuffer amount);
}
public static native void wlc_set_pointer_scroll_cb(Cb_Pointer_int_wlc_modifiers_byte_DoubleBuffer cb);
public static class Cb_Pointer_int_wlc_modifiers_byte_double__ extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_Pointer_int_wlc_modifiers_byte_double__(Pointer p) { super(p); }
    protected Cb_Pointer_int_wlc_modifiers_byte_double__() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int time, @Const wlc_modifiers arg2, @Cast("uint8_t") byte axis_bits, double[] amount);
}
public static native void wlc_set_pointer_scroll_cb(Cb_Pointer_int_wlc_modifiers_byte_double__ cb);

/** Motion event was triggered, view handle will be zero if there was no focus. Apply with wlc_pointer_set_position to agree. Return true to prevent sending the event to clients. */
public static native void wlc_set_pointer_motion_cb(Cb_Pointer_int_wlc_point cb);

/** Touch event was triggered, view handle will be zero if there was no focus. Return true to prevent sending the event to clients. */
public static native void wlc_set_touch_cb(Cb_Pointer_int_wlc_modifiers_int_int_wlc_point cb);

/** Compositor is ready to accept clients. */
public static class Cb extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb(Pointer p) { super(p); }
    protected Cb() { allocate(); }
    private native void allocate();
    public native void call();
}
public static native void wlc_set_compositor_ready_cb(Cb cb);

/** Compositor is about to terminate */
public static native void wlc_set_compositor_terminate_cb(Cb cb);

/** Input device was created. Return value does nothing. (Experimental) */
public static class Cb_libinput_device extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_libinput_device(Pointer p) { super(p); }
    protected Cb_libinput_device() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(libinput_device device);
}
public static native void wlc_set_input_created_cb(Cb_libinput_device cb);

/** Input device was destroyed. (Experimental) */
public static native void wlc_set_input_destroyed_cb(Cb_libinput_device cb);

/** -- Core API */

/** Set log handler. Can be set before wlc_init. */
public static class Cb_int_BytePointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_int_BytePointer(Pointer p) { super(p); }
    protected Cb_int_BytePointer() { allocate(); }
    private native void allocate();
    public native void call(@Cast("wlc_log_type") int type, @Cast("const char*") BytePointer str);
}
public static native void wlc_log_set_handler(Cb_int_BytePointer cb);
public static class Cb_int_String extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_int_String(Pointer p) { super(p); }
    protected Cb_int_String() { allocate(); }
    private native void allocate();
    public native void call(@Cast("wlc_log_type") int type, String str);
}
public static native void wlc_log_set_handler(Cb_int_String cb);

/**
 * Initialize wlc. Returns false on failure.
 *
 * Avoid running unverified code before wlc_init as wlc compositor may be run with higher
 * privileges on non logind systems where compositor binary needs to be suid.
 *
 * wlc_init's purpose is to initialize and drop privileges as soon as possible.
 *
 * Callbacks should be set using wlc_set_*_cb functions before calling wlc_init,
 * failing to do so will cause any callback the init may trigger to not be called.
 */
public static native @Cast("bool") boolean wlc_init();

/** Terminate wlc. */
public static native void wlc_terminate();

/** Query backend wlc is using. */
public static native @Cast("wlc_backend_type") int wlc_get_backend_type();

/** Exec program. */
 

/** Run event loop. */
public static native void wlc_run();

/** Link custom data to handle. */
public static native void wlc_handle_set_user_data(@ByVal @Cast("wlc_handle*") Pointer handle, @Const Pointer userdata);

/** Get linked custom data from handle. */
public static native Pointer wlc_handle_get_user_data(@ByVal @Cast("wlc_handle*") Pointer handle);

/** Add fd to event loop. Return value of callback is unused, you should return 0. */
 public static class Cb_int_int_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Cb_int_int_Pointer(Pointer p) { super(p); }
    protected Cb_int_int_Pointer() { allocate(); }
    private native void allocate();
    public native int call(int fd, @Cast("uint32_t") int mask, Pointer userdata);
}
public static native wlc_event_source wlc_event_loop_add_fd(int fd, @Cast("uint32_t") int mask, Cb_int_int_Pointer cb, Pointer userdata);

/** Add timer to event loop. Return value of callback is unused, you should return 0. */
 public static native wlc_event_source wlc_event_loop_add_timer(Cb_Pointer cb, Pointer userdata);

/** Update timer to trigger after delay. Returns true on success. */
public static native @Cast("bool") boolean wlc_event_source_timer_update(wlc_event_source source, int ms_delay);

/** Remove event source from event loop. */
public static native void wlc_event_source_remove(wlc_event_source source);

/** -- Output API */

/** Get outputs. Returned array is a direct reference, careful when moving and destroying handles. */
public static native @Cast("const wlc_handle*") Pointer wlc_get_outputs(@Cast("size_t*") SizeTPointer out_memb);

/** Get focused output. */
public static native @ByVal @Cast("wlc_handle*") Pointer wlc_get_focused_output();

/** Get output name. */
public static native @Cast("const char*") BytePointer wlc_output_get_name(@ByVal @Cast("wlc_handle*") Pointer output);

/** Get sleep state. */
public static native @Cast("bool") boolean wlc_output_get_sleep(@ByVal @Cast("wlc_handle*") Pointer output);

/** Wake up / sleep. */
public static native void wlc_output_set_sleep(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("bool") boolean sleep);

/**
 * Get real resolution.
 * Resolution applied by either wlc_output_set_resolution call or initially.
 * Do not use this for coordinate boundary.
 */
public static native @Const wlc_size wlc_output_get_resolution(@ByVal @Cast("wlc_handle*") Pointer output);

/**
 * Get virtual resolution.
 * Resolution with transformations applied for proper rendering for example on high density displays.
 * Use this to figure out coordinate boundary.
 */
public static native @Const wlc_size wlc_output_get_virtual_resolution(@ByVal @Cast("wlc_handle*") Pointer output);

/** Set resolution. */
public static native void wlc_output_set_resolution(@ByVal @Cast("wlc_handle*") Pointer output, @Const wlc_size resolution, @Cast("uint32_t") int scale);

/** Get scale factor. */
public static native @Cast("uint32_t") int wlc_output_get_scale(@ByVal @Cast("wlc_handle*") Pointer output);

/** Get current visibility bitmask. */
public static native @Cast("uint32_t") int wlc_output_get_mask(@ByVal @Cast("wlc_handle*") Pointer output);

/** Set visibility bitmask. */
public static native void wlc_output_set_mask(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("uint32_t") int mask);

/** Get views in stack order. Returned array is a direct reference, careful when moving and destroying handles. */
public static native @Cast("const wlc_handle*") Pointer wlc_output_get_views(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("size_t*") SizeTPointer out_memb);

/**
 * Get mutable views in creation order. Returned array is a direct reference, careful when moving and destroying handles.
 * This is mainly useful for wm's who need another view stack for inplace sorting.
 * For example tiling wms, may want to use this to keep their tiling order separated from floating order.
 */
public static native @Cast("wlc_handle*") Pointer wlc_output_get_mutable_views(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("size_t*") SizeTPointer out_memb);

/** Set views in stack order. This will also change mutable views. Returns false on failure. */
public static native @Cast("bool") boolean wlc_output_set_views(@ByVal @Cast("wlc_handle*") Pointer output, @Cast("const wlc_handle*") Pointer views, @Cast("size_t") long memb);

/** Focus output. Pass zero for no focus. */
public static native void wlc_output_focus(@ByVal @Cast("wlc_handle*") Pointer output);

/** -- View API */

/** Focus view. Pass zero for no focus. */
public static native void wlc_view_focus(@ByVal @Cast("wlc_handle*") Pointer view);

/** Close view. */
public static native void wlc_view_close(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get current output. */
public static native @ByVal @Cast("wlc_handle*") Pointer wlc_view_get_output(@ByVal @Cast("wlc_handle*") Pointer view);

/** Set output. Alternatively you can wlc_output_set_views. */
public static native void wlc_view_set_output(@ByVal @Cast("wlc_handle*") Pointer view, @ByVal @Cast("wlc_handle*") Pointer output);

/** Send behind everything. */
public static native void wlc_view_send_to_back(@ByVal @Cast("wlc_handle*") Pointer view);

/** Send below another view. */
public static native void wlc_view_send_below(@ByVal @Cast("wlc_handle*") Pointer view, @ByVal @Cast("wlc_handle*") Pointer other);

/** Send above another view. */
public static native void wlc_view_bring_above(@ByVal @Cast("wlc_handle*") Pointer view, @ByVal @Cast("wlc_handle*") Pointer other);

/** Bring to front of everything. */
public static native void wlc_view_bring_to_front(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get current visibility bitmask. */
public static native @Cast("uint32_t") int wlc_view_get_mask(@ByVal @Cast("wlc_handle*") Pointer view);

/** Set visibility bitmask. */
public static native void wlc_view_set_mask(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int mask);

/** Get current geometry. (what client sees) */
public static native @Const wlc_geometry wlc_view_get_geometry(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get visible geometry. (what wlc displays) */
public static native void wlc_view_get_visible_geometry(@ByVal @Cast("wlc_handle*") Pointer view, wlc_geometry out_geometry);

/** Set geometry. Set edges if the geometry change is caused by interactive resize. */
public static native void wlc_view_set_geometry(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("uint32_t") int edges, @Const wlc_geometry geometry);

/** Get type bitfield. */
public static native @Cast("uint32_t") int wlc_view_get_type(@ByVal @Cast("wlc_handle*") Pointer view);

/** Set type bit. Toggle indicates whether it is set or not. */
public static native void wlc_view_set_type(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("wlc_view_type_bit") int type, @Cast("bool") boolean toggle);

/** Get current state bitfield. */
public static native @Cast("uint32_t") int wlc_view_get_state(@ByVal @Cast("wlc_handle*") Pointer view);

/** Set state bit. Toggle indicates whether it is set or not. */
public static native void wlc_view_set_state(@ByVal @Cast("wlc_handle*") Pointer view, @Cast("wlc_view_state_bit") int state, @Cast("bool") boolean toggle);

/** Get parent view. */
public static native @ByVal @Cast("wlc_handle*") Pointer wlc_view_get_parent(@ByVal @Cast("wlc_handle*") Pointer view);

/** Set parent view. */
public static native void wlc_view_set_parent(@ByVal @Cast("wlc_handle*") Pointer view, @ByVal @Cast("wlc_handle*") Pointer parent);

/** Get title. */
public static native @Cast("const char*") BytePointer wlc_view_get_title(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get class. (shell-surface only) */
public static native @Cast("const char*") BytePointer wlc_view_get_class(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get app id. (xdg-surface only) */
public static native @Cast("const char*") BytePointer wlc_view_get_app_id(@ByVal @Cast("wlc_handle*") Pointer view);

/** Get pid. */
public static native @Cast("pid_t") int wlc_view_get_pid(@ByVal @Cast("wlc_handle*") Pointer view);

/** --  Input API
 * Very recent stuff, things may change.
 * XXX: This api is dumb and assumes there is only single xkb state and keymap.
 *      In case of multiple keyboards, we want to each keyboard have own state and layout.
 *      Thus we need wlc_handle for keyboards eventually. */

/** Internal xkb_state exposed. You can use it to do more advanced key handling.
 *  However you should avoid messing up with its state. */
public static native xkb_state wlc_keyboard_get_xkb_state();

/** Internal xkb_keymap exposed. You can use it to do more advanced key handling. */
public static native xkb_keymap wlc_keyboard_get_xkb_keymap();

/** Get currently held keys. */
public static native @Cast("const uint32_t*") IntPointer wlc_keyboard_get_current_keys(@Cast("size_t*") SizeTPointer out_memb);

/** Utility function to convert raw keycode to keysym. Passed modifiers may transform the key. */
public static native @Cast("uint32_t") int wlc_keyboard_get_keysym_for_key(@Cast("uint32_t") int key, @Const wlc_modifiers modifiers);

/** Utility function to convert raw keycode to Unicode/UTF-32 codepoint. Passed modifiers may transform the key. */
public static native @Cast("uint32_t") int wlc_keyboard_get_utf32_for_key(@Cast("uint32_t") int key, @Const wlc_modifiers modifiers);

/** Get current pointer position. */
public static native void wlc_pointer_get_position(wlc_point out_position);

/** Set current pointer position. */
public static native void wlc_pointer_set_position(@Const wlc_point position);

// #ifdef __cplusplus
// #endif

// #endif /* _WLC_H_ */


// Parsed from <wlc/wlc-wayland.h>

// #ifndef _WLC_WAYLAND_H_
// #define _WLC_WAYLAND_H_

// #ifdef __cplusplus
// #endif

// #include <wlc/defines.h>
// #include <wlc/geometry.h>
// #include <wayland-server.h>

@Opaque public static class wl_resource extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public wl_resource() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wl_resource(Pointer p) { super(p); }
}
@Opaque public static class wl_display extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public wl_display() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wl_display(Pointer p) { super(p); }
}

/** Returns Wayland display. */
public static native wl_display wlc_get_wl_display();

/** Returns view handle from wl_surface resource. */
public static native @ByVal @Cast("wlc_handle*") Pointer wlc_handle_from_wl_surface_resource(wl_resource resource);

/** Returns output handle from wl_output resource. */
public static native @ByVal @Cast("wlc_handle*") Pointer wlc_handle_from_wl_output_resource(wl_resource resource);

/** Returns internal wlc surface from wl_surface resource. */
public static native @Cast("wlc_resource") long wlc_resource_from_wl_surface_resource(wl_resource resource);

/** Get surface size. */
public static native @Const wlc_size wlc_surface_get_size(@Cast("wlc_resource") long surface);

/** Return wl_surface resource from internal wlc surface. */
public static native wl_resource wlc_surface_get_wl_resource(@Cast("wlc_resource") long surface);

/**
 * Turns wl_surface into a wlc view. Returns 0 on failure. This will also trigger view.created callback as any view would.
 * For the extra arguments see details of wl_resource_create and wl_resource_set_implementation.
 * The extra arguments may be set NULL, if you are not implementing Wayland interface for the surface role.
 */


/** Returns internal wlc surface from view handle */
public static native @Cast("wlc_resource") long wlc_view_get_surface(@ByVal @Cast("wlc_handle*") Pointer view);

/** Returns a list of the subsurfaces of the given surface */
public static native @Cast("const wlc_resource*") SizeTPointer wlc_surface_get_subsurfaces(@Cast("wlc_resource") long parent, @Cast("size_t*") SizeTPointer out_size);

/** Returns the size of a subsurface and its position relative to parent */
public static native void wlc_get_subsurface_geometry(@Cast("wlc_resource") long surface, wlc_geometry out_geometry);

/** Returns wl_client from view handle */
public static native @Cast("wl_client*") Pointer wlc_view_get_wl_client(@ByVal @Cast("wlc_handle*") Pointer view);

/** Returns surface role resource from view handle. Return value will be NULL if the view was not assigned role or created with wlc_view_create_from_surface(). */
public static native wl_resource wlc_view_get_role(@ByVal @Cast("wlc_handle*") Pointer view);

// #ifdef __cplusplus
// #endif

// #endif /* _WLC_WAYLAND_H_ */


// Parsed from <wlc/wlc-render.h>

// #ifndef _WLC_RENDER_H_
// #define _WLC_RENDER_H_

// #ifdef __cplusplus
// #endif

// #include <wlc/defines.h>
// #include <wlc/geometry.h>
// #include <wlc/wlc-wayland.h>

/**
 * The functions in this file provide some basic rendering capabilities.
 * *_render(), *_read(), *_write() functions should only be called during post/pre render callbacks.
 * wlc_output_schedule_render() is exception and may be used to force wlc to render new frame (causing callbacks to trigger).
 *
 * For more advanced drawing you should directly use GLES2.
 * This is not documented as it's currently relying on the implementation details of wlc.
 */

/** Allowed pixel formats. */
/** enum wlc_pixel_format */
public static final int
   WLC_RGBA8888 = 0;

/**
 * Write pixel data with the specific format to output's framebuffer.
 * If the geometry is out of bounds, it will be automaticall clamped.
 */
public static native void wlc_pixels_write(@Cast("wlc_pixel_format") int format, @Const wlc_geometry geometry, @Const Pointer data);

/**
 * Read pixel data from output's framebuffer.
 * If the geometry is out of bounds, it will be automatically clamped.
 * Potentially clamped geometry will be stored in out_geometry, to indicate width / height of the returned data.
 */
public static native void wlc_pixels_read(@Cast("wlc_pixel_format") int format, @Const wlc_geometry geometry, wlc_geometry out_geometry, Pointer out_data);

/** Renders surface. */
public static native void wlc_surface_render(@Cast("wlc_resource") long surface, @Const wlc_geometry geometry);

/**
 * Schedules output for rendering next frame. If output was already scheduled this is no-op,
 * if output is currently rendering, it will render immediately after.
 */
public static native void wlc_output_schedule_render(@ByVal @Cast("wlc_handle*") Pointer output);

/**
 * Adds frame callbacks of the given surface for the next output frame.
 * It applies recursively to all subsurfaces.
 * Useful when the compositor creates custom animations which require disabling internal rendering,
 * but still need to update the surface textures (for ex. video players).
 */
public static native void wlc_surface_flush_frame_callbacks(@Cast("wlc_resource") long surface);

/** Enabled renderers */
/** enum wlc_renderer */
public static final int
    WLC_RENDERER_GLES2 = 0,
    WLC_NO_RENDERER = 1;

/** Returns currently active renderer on the given output */
public static native @Cast("wlc_renderer") int wlc_output_get_renderer(@ByVal @Cast("wlc_handle*") Pointer output);

/** enum wlc_surface_format */
public static final int
    SURFACE_RGB = 0,
    SURFACE_RGBA = 1,
    SURFACE_EGL = 2,
    SURFACE_Y_UV = 3,
    SURFACE_Y_U_V = 4,
    SURFACE_Y_XUXV = 5;

/**
 * Fills out_textures[] with the textures of a surface. Returns false if surface is invalid.
 * Array must have at least 3 elements and should be refreshed at each frame.
 * Note that these are not only OpenGL textures but rather render-specific.
 * For more info what they are check the renderer's source code */
public static native @Cast("bool") boolean wlc_surface_get_textures(@Cast("wlc_resource") long surface, @Cast("uint32_t*") IntPointer out_textures, @Cast("wlc_surface_format*") IntPointer out_format);
public static native @Cast("bool") boolean wlc_surface_get_textures(@Cast("wlc_resource") long surface, @Cast("uint32_t*") IntBuffer out_textures, @Cast("wlc_surface_format*") IntBuffer out_format);
public static native @Cast("bool") boolean wlc_surface_get_textures(@Cast("wlc_resource") long surface, @Cast("uint32_t*") int[] out_textures, @Cast("wlc_surface_format*") int[] out_format);

// #ifdef __cplusplus
// #endif

// #endif /* _WLC_RENDER_H_ */


// Parsed from <wlc/geometry.h>

// #ifndef _WLC_GEOMETRY_H_
// #define _WLC_GEOMETRY_H_

// #ifdef __cplusplus
// #endif 

// #include <wlc/defines.h>
// #include <stdbool.h>
// #include <stdint.h>
// #include <string.h>
// #include <assert.h>

// #ifndef MIN
// #  define MIN(a, b) ((a) < (b) ? (a) : (b))
// #endif

// #ifndef MAX
// #  define MAX(a, b) ((a) > (b) ? (a) : (b))
// #endif

/** Fixed 2D point */
public static class wlc_point extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wlc_point() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wlc_point(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wlc_point(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wlc_point position(long position) {
        return (wlc_point)super.position(position);
    }

   public native int x(); public native wlc_point x(int x);
   public native int y(); public native wlc_point y(int y);
}

/** wlc_origin is depreacted in favor of wlc_point */
// #define wlc_origin wlc_point __attribute__((deprecated("wlc_origin is deprecated, use wlc_point instead")))

/** Fixed 2D size */
public static class wlc_size extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wlc_size() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wlc_size(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wlc_size(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wlc_size position(long position) {
        return (wlc_size)super.position(position);
    }

   public native @Cast("uint32_t") int w(); public native wlc_size w(int w);
   public native @Cast("uint32_t") int h(); public native wlc_size h(int h);
}

/** Fixed 2D point, size pair */
public static class wlc_geometry extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wlc_geometry() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wlc_geometry(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wlc_geometry(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wlc_geometry position(long position) {
        return (wlc_geometry)super.position(position);
    }

   public native @ByRef wlc_point origin(); public native wlc_geometry origin(wlc_point origin);
   public native @ByRef wlc_size size(); public native wlc_geometry size(wlc_size size);
}

@MemberGetter public static native @Const @ByRef wlc_point wlc_origin_zero();
@MemberGetter public static native @Const @ByRef wlc_point wlc_point_zero();
@MemberGetter public static native @Const @ByRef wlc_size wlc_size_zero();
@MemberGetter public static native @Const @ByRef wlc_geometry wlc_geometry_zero();

public static native void wlc_point_min(@Const wlc_point a, @Const wlc_point b, wlc_point out);

public static native void wlc_point_max(@Const wlc_point a, @Const wlc_point b, wlc_point out);

public static native void wlc_size_min(@Const wlc_size a, @Const wlc_size b, wlc_size out);

public static native void wlc_size_max(@Const wlc_size a, @Const wlc_size b, wlc_size out);

public static native @Cast("bool") boolean wlc_point_equals(@Const wlc_point a, @Const wlc_point b);

public static native @Cast("bool") boolean wlc_size_equals(@Const wlc_size a, @Const wlc_size b);

public static native @Cast("bool") boolean wlc_geometry_equals(@Const wlc_geometry a, @Const wlc_geometry b);

public static native @Cast("bool") boolean wlc_geometry_contains(@Const wlc_geometry a, @Const wlc_geometry b);

// #ifdef __cplusplus
// #endif 

// #endif /* _WLC_GEOMETRY_H_ */


}
